/**
 * @page Examples Examples
 *
 * Here is a page with examples.
 *
 * @li @ref tutorial_ephysics_bouncing_ball
 * @li @ref tutorial_ephysics_bouncing_text
 * @li @ref tutorial_ephysics_collision_detection
 * @li @ref tutorial_ephysics_collision_filter
 * @li @ref tutorial_ephysics_delete_body
 * @li @ref tutorial_ephysics_constraint
 * @li @ref tutorial_ephysics_gravity
 * @li @ref tutorial_ephysics_velocity
 */

/**
 * @page tutorial_ephysics_bouncing_ball EPhysics - Bouncing Ball
 *
 * The purpose of this example is to show how to write an simple application -
 * as the name suggests - with a small ball bouncing on the ground and
 * responding to users events by making it jump - applying a central impulse on
 * it.
 *
 * We'll guide you on defining a EPhysics world, defining its render geometry
 * and the physics limiting boundaries, you'll learn how to add EPhysics bodies
 * and how to associate it to evas objects.  We also explain how to change
 * restitution and friction properties. We see how to apply central impulse on
 * a EPhysics_Body by implementing an elementary input event callback and
 * calling the proper function.
 *
 * @section test-structure A test struct
 * @dontinclude ephysics_test.h
 *
 * While in this example we'll be working with a struct to hold some objects in
 * our code. For clarity sake we present you the struct declaration in the
 * following block.
 *
 *
 * @skip struct _Test_Data
 * @until };
 *
 * @section world-new World Initialization 
 * @dontinclude test_bouncing_ball.c
 *
 * Calling ephysics_world_new()
 * will create a new physics world with its collision configuration, constraint
 * solver, broadphase interface and dispatcher.
 *
 * The default gravity is set to -9.81. It's possible to stop a running world
 * but its default status is running. Take a look at
 * ephysics_world_running_set() for further informations about world running
 * status.
 *
 * @skipline ephysics_world_new
 *
 * @section render-geometry Render geometry
 *
 * By setting the render geometry you tell ephysics the dimensions of rendered
 * area to be take on account by default updates.
 *
 * By default it starts with null x, y, width and height. Initially there's no
 * physics limits but - as we'll see later in this example - boundaries can be
 * added by issuing either ephysics_body_top_boundary_add(),
 * ephysics_body_bottom_boundary_add(), ephysics_body_left_boundary_add() and
 * ephysics_body_right_boundary_add().
 *
 * While setting the worlds render geometry the first parameter is our just
 * created world, the following parameters indicate the x, y, width and height
 * of our area of interest.
 *
 * @skipline ephysics_world_render_geometry_set
 *
 * @section boundaries Adding boundaries
 *
 * Boundaries are physics limits added by EPhysics which you can use to limit
 * the area where your objects can move around. Bear in mind that those
 * boundaries are created by EPhysics taking in account the render geometry you
 * have previously defined by calling ephysics_world_render_geometry_set().
 *
 * In our example we start by adding a bottom boundary. This EPhysics_Body
 * represents a physics limit under the world render geometry.
 *
 * The second line states the restitution factor for that bottom boundary, and
 * the third line its friction. These changes will make our ball to bounce
 * whenever it hits the ground.
 *
 * @skip ephysics_body_bottom_boundary_add
 * @until ephysics_body_friction_set 
 *
 * Then we add a right boundary limiting the physics world on the left side, we
 * also change its restitution and friction factors but with a smaller value,
 * we don't want to make it bounce as much as it is when hits the ground. 
 *
 * @skip ephysics_body_right_boundary_add
 * @until ephysics_body_friction_set 
 *
 * We also add a left boundary taking the same considerations for right
 * boundary.
 *
 * @skip ephysics_body_left_boundary_add
 * @until ephysics_body_friction_set 
 *
 * One of this examples requirements is to make the ball jump after a specific
 * user event, so the ball can suffer an impulse for any direction.
 *
 * With an upper impulse we don't want our ball to fly all over there, we want
 * to limit its upper movements, it's intended to limit the ball movement
 * within a box, it should not leave the render geometry area, for that purpose
 * we must define a top boundary. 
 *
 * @skipline ephysics_body_top_boundary_add
 * @dontinclude test_bouncing_ball.c
 *
 * @section world-populate Adding a ball
 *
 * Since we have defined the physics limits with our boundaries it's time to
 * add some fun. Here we add a ball as an elementary image widget and tell
 * ephysics about it.
 *
 * After setting the file that will be used as the image's source of our elm
 * image we move it to the center of render geometry and resize it to 70x70
 * pixels and show it.
 *
 * @skip elm_image_add
 * @until evas_object_show
 *
 * The evas object is just set and we must tell EPhysics about it, creating the
 * EPhysics_Body representing our ball and associating it to the just created
 * evas object.
 *
 * Once the ball has been moved to the center of render geometry it should
 * start falling after associating it to the EPhysics_Body. By default its mass
 * is initially set to 1 kilo, but it can be changed by calling
 * ephysics_body_mass_set(). Bear in mind that if you change its mass to 0
 * kilos it becomes a static body and will not move at all, the body will
 * remain fixed in the initial position.
 *
 * In the following code the first line adds a circle body, then we associate
 * the evas object to EPhysics_Body, EPhysics will map every changes on physics
 * object simulation to its evas object. Some restitution and friction factors
 * are added as well.
 *
 * @skip ephysics_body_circle_add
 * @until ephysics_body_friction_set
 *
 * @section jumping-ball Making it jump
 *
 * The next step is to give us the ability to make our ball to jump - actually
 * apply some impulse whenever a key has been pressed. Then we add a elementary
 * input callback to the window widget.
 *
 * @skipline elm_object_event_callback_add
 *
 * @dontinclude test_bouncing_ball.c
 *
 * The jumping callback implementation consists on handling only key up events
 * and discarding any other input event we get. We're interested on keyboard
 * events only. All the operations done in the following lines are done on
 * sphere EPhysics_Body previously created.
 *
 * We mainly use the ephysics_body_central_impulse_apply() function. This
 * function applies an inpulse on the center of a body.
 *
 * Once pressed \<Up> key it applies a central impulse of 0 kilos on X axis and
 * 10 kilos on Y - so the ball is forced up. 
 *
 * If \<Down> key has been pressed we apply an impulse of 0 kilos on X axis and
 * -10 on Y - here the ball is forced down. 
 *
 * In the case of \<Right> key pressing it's applied an impulse of 10 kilos on X
 * axis and 0 kilos on Y - which applies a force to the right side. But if the
 * key being pressed is \<Left> the opposite is done, and an impulse of -10
 * kilos is applied on X and 0 kilos on Y - and the ball is forced to the left.
 *
 * @skip _on_keydown
 * @until }
 *
 * Here we finish the very simple bouncing ball example. The full source code
 * can be found at @ref test_bouncing_ball_c.
 *
 */

/**
 * @page test_bouncing_ball_c test_bouncing_ball.c
 *
 * @section ephysics-test-h ephysics_test.h
 * @include ephysics_test.h
 *
 * @section test-bouncing-ball-c test_bouncing_ball.c
 * @dontinclude test.c
 * @skip test_clean
 * @until }
 *
 * @skip test_data_new
 * @until }
 *
 * @skip test_win_add
 * @until }
 *
 * @include test_bouncing_ball.c
 *
 *
 * @example test_bouncing_ball.c
 */

/**
 * @page ephysics_logo_c ephysics_logo.c
 *
 * @section ephysics-logo-c ephysics_logo.c
 * @include ephysics_logo.c
 *
 * @example ephysics_logo.c
 */
 
/**
 * @page tutorial_ephysics_bouncing_text EPhysics - Bouncing Text
 *
 * The purpose of this example is to demonstrate the EPhysics_Body binding to
 * a text (Evas_Object)
 *
 * For this example we'll have an EPhysics_World and one basic EPhysics_Body.
 *
 * The basic concepts like - initializing an EPhysics_World, render geometry,
 * physics limiting boundaries, were already covered in 
 * @ref tutorial_ephysics_bouncing_ball
 *
 * @section add-text Creating the text
 * @dontinclude test_bouncing_text.c
 *
 * Create a basic evas_object_text.
 *
 * @skipline Evas_Object *text;
 *
 * @skip text =
 * @until text);
 *
 * @section add-textbody Creating the body
 *
 * Create a simple EPhysics_Body.
 *
 * Note that we use ephysics_body_geometry_set() to define its size because
 * the evas_object has a different size that we want to represent physically.
 * The text may have accent or letters like j and g.
 *
 * @skipline text_body =
 * @skip ephysics_body_geometry_set(text_body
 * @until 0.1);
 *
 * @section text-binding Binding
 * @dontinclude test_bouncing_text.c
 *
 * After create the body and the text, now we need to bind them.
 *
 * We set the last parameter as EINA_FALSE because in this example we don't
 * want to set the physics body position to match evas object position.
 *
 * @skipline ephysics_body_evas_object_set
 *
 * Here we finish the example. The full source code can be found at
 * @ref test_bouncing_text_c.
 *
 */

 /**
 * @page test_bouncing_text_c test_bouncing_text.c
 *
 * @section ephysics-test-h ephysics_test.h
 * @include ephysics_test.h
 *
 * @section test-bouncing_text-c test_bouncing_text.c
 * @dontinclude test.c
 *
 * @skip test_clean
 * @until }
 *
 * @skip test_data_new
 * @until }
 *
 * @skip test_win_add
 * @until }
 *
 * @include test_bouncing_text.c
 *
 * @example test_bouncing_text.c
 */

/**
 * @page tutorial_ephysics_collision_detection EPhysics - Collision Detection
 *
 * The purpose of this example is to demonstrate the EPhysics Collision
 * Detection usage - The code adds two balls, one with impulse and the second
 * with a collision detection callback, to show an effect.
 *
 * For this example we'll have an EPhysics_World, and two basic EPhysics_Bodys,
 * we'll apply an impulse in one of then and the other will be stopped
 * "waiting" for a collision.
 *
 * The basic concepts like - initializing an EPhysics_World, render geometry,
 * physics limiting boundaries, add an Ephysics_Body, associate it to evas
 * objects, change restitution, friction and impulse properties, were
 * already covered in
 * @ref tutorial_ephysics_bouncing_ball
 *
 * @section add-collstruct Collision Data Struct
 * @dontinclude test_collision_detection.c
 *
 * While in this example we'll be working with a struct to hold some objects
 * in our code. For clarity sake we present you the struct declaration in the
 * following block.
 *
 * @skip struct _Collision_Data {
 * @until };
 *
 * @section add-callbacks Adding the Callback
 *
 * Calling ephysics_body_event_callback_add()
 * will register a callback to a type of physics body event.
 *
 * @ref EPHYSICS_CALLBACK_BODY_COLLISION : called just after the collision has
 * been actually processed by the physics engine. In other words, to be
 * notified about a collision between two physical bodies.
 *
 * @skip ephysics_body_event_callback_add(collision_data->sphere
 * @until );
 *
 * See
 * @ref _EPhysics_Callback_Body_Type
 * for more event types.
 *
 * @section add-collcb Collision Function
 *
 * The callback function will filter the collision to be sure if that body is
 * which we want and then show the effect.
 *
 * First we need to create a specific variable type to get collision infos: 
 * @ref EPhysics_Body_Collision
 *
 * @dontinclude test_collision_detection.c
 *
 * @skip _collision_cb
 * @until int x, y;
 *
 * Now we want to know which body collides with and filter it.
 *
 * @skip contact_body =
 * @until return;
 *
 * We just get the collision position, move the impact effect to this
 * coordinate and send a signal to edje to show it.
 *
 * @skip ephysics_body_collision_position_get
 * @until "ephysics_test");
 * @skipline }
 *
 * Here we finish the example. The full source code can be found at
 * @ref test_collision_detection_c.
 *
 */

 /**
 * @page test_collision_detection_c test_collision_detection.c
 *
 * @section ephysics-test-h ephysics_test.h
 * @include ephysics_test.h
 *
 * @section test-collision_detection-c test_collision_detection.c
 * @dontinclude test.c
 *
 * @skip test_clean
 * @until }
 *
 * @skip test_win_add
 * @until }
 *
 * @include test_collision_detection.c
 *
 * @example test_collision_detection.c
 */

/**
 * @page tutorial_ephysics_collision_filter EPhysics - Collision Filter
 *
 * The purpose of this example is to demonstrate the EPhysics Collision Filter
 * usage - The code adds four balls in 2 rows and 2 columns, two on each
 * collision group, the collision only happens when the balls are in the
 * same group (row),to make it easier, balls in the same group has the same
 * color and size.
 *
 * For this example we'll have an EPhysics_World and four basic EPhysics_Bodys,
 * we'll apply an impulse on then and see what happens when they're in other
 * collision group.
 *
 * The basic concepts like - initializing an EPhysics_World, render geometry,
 * physics limiting boundaries, add an Ephysics_Body, associate it to evas
 * objects, change restitution, friction and impulse properties, were
 * already covered in
 * @ref tutorial_ephysics_bouncing_ball
 *
 * @section add-callbacks Adding the balls
 * @dontinclude test_collision_filter.c
 *
 * We'll use two arrays (color and size) to distinguish the groups.
 *
 * @skip _world_populate
 * @until row;
 *
 * The balls declaration was placed into a For loop, just to simplify the
 * coding and divide them in two groups.
 *
 * @skip for (i = 0; i < 4
 * @until 0.1);
 *
 * Note in this part we divide the balls in two groups by color (row).
 *
 * @skipline ephysics_body_collision_group_add(fall_body
 *
 * The impulse will be applied in only 1 ball per group, in this case:
 *
 * The 1st row 2nd column ball will be applied an impulse to the
 * left (-300kg * p/s).
 *
 * The 2nd row 1st column ball will be applied an impulse to the
 * right (300kg * p/s).
 *
 * And then saving the body into a list.
 *
 * @skip if (column + row == 1
 * @until }
 * @skipline }
 *
 * Here we finish the example. The full source code can be found at
 * @ref test_collision_filter_c.
 *
 */

 /**
 * @page test_collision_filter_c test_collision_filter.c
 *
 * @section ephysics-test-h ephysics_test.h
 * @include ephysics_test.h
 *
 * @section test-collision_filter-c test_collision_filter.c
 * @dontinclude test.c
 *
 * @skip test_clean
 * @until }
 *
 * @skip test_data_new
 * @until }
 *
 * @skip test_win_add
 * @until }
 *
 * @include test_collision_filter.c
 *
 * @example test_collision_filter.c
 */

/**
 * @page tutorial_ephysics_delete_body EPhysics - Delete Body
 *
 * The purpose of this example is to demonstrate the EPhysics Callbacks usage -
 * The code adds two balls, one with impulse and the second with a collision
 * detection callback, to delete the body.
 *
 * For this example we'll have an EPhysics_World and two basic EPhysics_Bodys,
 * we'll apply an impulse in one of then and the other will be stopped
 * "waiting" for a collision.
 *
 * The basic concepts like - initializing an EPhysics_World, render geometry,
 * physics limiting boundaries, add an EPhysics_Body, associate it to evas
 * objects, change restitution, friction and impulse properties, were already
 * covered in
 * @ref tutorial_ephysics_bouncing_ball
 *
 * @section add-callbacks Adding Callbacks
 * @dontinclude test_delete.c
 *
 * Calling ephysics_body_event_callback_add()
 * registers a callback to a given EPhysics_Body event type.
 *
 * We'll use two types:
 *
 * @ref EPHYSICS_CALLBACK_BODY_DEL : called when a body deletion has been issued
 * and just before the deletion actually happens. In other words, to know that
 * body has been marked for
 * deletion. Typically to free some data associated with the body.
 *
 * @skipline ephysics_body_event_callback_add(sphere_body1,
 * @skip EPHYSICS_CALLBACK_BODY_DEL
 * @until );
 *
 * The callback function will receive the collision_data and free some data
 * associated with the body.
 *
 * @dontinclude test_delete.c
 *
 * @skip _del_cb(void *data,
 * @until }
 *
 * @ref EPHYSICS_CALLBACK_BODY_COLLISION : called just after the collision has
 * been actually processed by the physics engine. In other words, to be notified
 * about a collision between two physical bodies.
 *
 * @skip ephysics_body_event_callback_add(collision_data->sphere,
 * @until );
 *
 * The callback function will get the collision body and check if its body is
 * equal to which we want to delete.
 *
 * @dontinclude test_delete.c
 *
 * @skip _collision_cb(void *data,
 * @until }
 *
 * See
 * @ref _EPhysics_Callback_Body_Type
 * for more event types.
 *
 * Here we finish the example. The full source code can be found at
 * @ref test_delete_c.
 *
 */
 
 /**
 * @page test_delete_c test_delete.c
 *
 * @section ephysics-test-h ephysics_test.h
 * @include ephysics_test.h
 *
 * @section test-delete-c test_delete.c
 * @dontinclude test.c
 * @skip test_clean
 * @until }
 *
 * @skip test_win_add
 * @until }
 *
 * @include test_delete.c
 *
 * @example test_delete.c
 */

 /**
 * @page tutorial_ephysics_constraint EPhysics - Constraint
 *
 * The purpose of this example is to demonstrate the EPhysics Constraint usage -
 * The code apply a constraint between two cubes.
 *
 * For this example we'll have an EPhysics_World, and two basic EPhysics_Bodys.
 *
 * The basic concepts like - defining an EPhysics_World, render geometry,
 * physics limiting boundaries, add an EPhysics_Body, associate it to evas
 * objects, change restitution, friction and impulse properties, were
 * already covered in
 * @ref tutorial_ephysics_bouncing_ball
 *
 * @section add-constraint Adding a constraint
 * @dontinclude test_constraint.c
 *
 * Constraint is a specific type of variable in EPhysics.
 *
 * @skipline EPhysics_Constraint
 *
 * Here we're working with a point-to-point constraint, its purpose is to join
 * two bodies limiting their movements based on specified anchors.
 *
 * After we create our 2 EPhysics_Bodys, now we'll add a constraint between
 * them and setting an anchor to first body's Y using a p2p constraint
 * (point to point).
 *
 * @skip constraint = ephysics_constraint_p2p
 * @until );
 *
 * Here we finish the example. The full source code can be found at
 * @ref test_constraint_c.
 *
 */

 /**
 * @page test_constraint_c test_constraint.c
 *
 * @section ephysics-test-h ephysics_test.h
 * @include ephysics_test.h
 *
 * @section test-constraint-c test_constraint.c
 * @dontinclude test.c
 *
 * @skip test_clean
 * @until }
 *
 * @skip test_data_new
 * @until }
 *
 * @skip test_win_add
 * @until }
 *
 * @include test_constraint.c
 *
 * @example test_constraint.c
 */

 /**
 * @page tutorial_ephysics_gravity EPhysics - Gravity
 *
 * The purpose of this example is to demonstrate the EPhysics Gravity usage -
 * The code apply gravity in an EPhysics_World with two cubes in movement.
 *
 * For this example we'll have an EPhysics_World, and two basic EPhysics_Bodys.
 *
 * The basic concepts like - defining an EPhysics_World, render geometry,
 * physics limiting boundaries, add an EPhysics_Body, associate it to evas
 * objects, change restitution, friction and impulse properties, were
 * already covered in
 * @ref tutorial_ephysics_bouncing_ball
 *
 * Concepts like velocity and sleeping threshold were already
 * covered in
 * @ref tutorial_ephysics_velocity and 
 * @ref tutorial_ephysics_sleeping_threshold
 *
 * @section add-gravity Setting Gravity
 * @dontinclude test_no_gravity.c
 *
 * Here we set EPhysics_worlds gravity in 2 axises (x, y) to (0, 0). Gravity
 * will act over bodies with mass over all the time.
 *
 * @skipline ephysics_world_gravity_set
 *
 * @section add-stopbody Stopping a Body
 * @dontinclude test_no_gravity.c
 *
 * We're using a button to call this function that receives test_data to stop
 * the chosen body.
 *
 * Stop angular and linear body movement, its equivalent to set linear velocity
 * to 0 on both axis and angular velocity to 0 as well.
 *
 * @skip _stop(void *data
 * @until body);
 * @skipline }
 *
 * Here we finish the example. The full source code can be found at
 * @ref test_no_gravity_c.
 *
 */

 /**
 * @page test_no_gravity_c test_no_gravity.c
 *
 * @section ephysics-test-h ephysics_test.h
 * @include ephysics_test.h
 *
 * @section test-no-gravity-c test_no_gravity.c
 * @dontinclude test.c
 *
 * @skip test_clean
 * @until }
 *
 * @skip test_data_new
 * @until }
 *
 * @skip test_win_add
 * @until }
 *
 * @include test_no_gravity.c
 *
 * @example test_no_gravity.c
 */

/**
 * @page tutorial_ephysics_velocity EPhysics - Velocity
 *
 * The purpose of this example is to demonstrate the EPhysics Velocity usage -
 * The code adds a small bouncing ball on the ground and responding to users
 * events by making it jump - applying a central impulse on it and showing its
 * velocity and acceleration.
 *
 * We'll see in this example how to get EPhysics_Body Linear and Angular
 * velocity and acceleration.
 *
 * For this example we'll have an EPhysics_World and one basic EPhysics_Body,
 * we'll apply impulses that follows user events, it were already covered in 
 * @ref tutorial_ephysics_bouncing_ball
 *
 * @section add-velstruct Velocity Data Struct
 * @dontinclude test_velocity.c
 *
 * While in this example we'll be working with a struct to hold some objects
 * in our code. For clarity sake we present you the struct declaration in the
 * following block.
 *
 * @skip struct _Velocity_Data {
 * @until };
 *
 * @section add-callbacks Adding the Callbacks
 *
 * Calling ephysics_body_event_callback_add()
 * will register a callback to a type of physics body event.
 *
 * @ref EPHYSICS_CALLBACK_BODY_UPDATE : called after every physics iteration.
 * In other words, will be called after each world tick.
 *
 * @skipline ephysics_body_event_callback_add(sphere_body, EPHYSICS_CALLBACK_
 * @skipline _update_vel_cb
 *
 * @ref EPHYSICS_CALLBACK_BODY_STOPPED : called when a body is found to be
 * stopped. In other words, when the body is not moving anymore.
 *
 * @skip ephysics_body_event_callback_add(sphere_body, EPHYSICS_CALLBACK_BODY_ST
 * @until );
 *
 * See
 * @ref _EPhysics_Callback_Body_Type
 * for more event types.
 *
 * @section add-velcb Velocity Function
 *
 * The callback function will be called on every physics iteration to show the
 * linear and angular velocity and acceleration.
 *
 * Here we're declaring the necessary variables to calculate acelerations and
 * delta time. And checking if its the first time to return before shows
 * informations about the velocity.
 *
 * @dontinclude test_velocity.c
 *
 * @skip _update_vel_cb(void *data,
 * @until EINA_TRUE;
 *
 * Get the delta time to use it soon to calculate the acceleration on every
 * physics iteration.
 *
 * @skip time_now = ecore_time_get();
 * @until time_now;
 *
 * Note in this part we get the angular and linear velocities.
 *
 * @skip vaz = ephysics_body
 * @until &vy);
 *
 * We need to handle the velocity using delta time to have the acceleration
 * on every tick. Check if its the first time to return before shows
 * informations about the velocity because we dont have the old aceletations
 * and then the calculation of this informations will be wrong.
 *
 * Here we calculate the aceletarions using this formula:
 *
 * (velocity - old_velocity) / delta_time;
 *
 * @skip aaz = (vaz -
 * @until return;
 *
 * Turning data into text, to pass it to edje shows on screen.
 *
 * @skip snprintf(buff,
 * @until "linear_acc", buff);
 * @skip snprintf(buff,
 * @until "angular_acc", buff);
 * @skipline }
 *
 * Here we finish the example. The full source code can be found at
 * @ref test_velocity_c.
 *
 */

 /**
 * @page test_velocity_c test_velocity.c
 *
 * @section ephysics-test-h ephysics_test.h
 * @include ephysics_test.h
 *
 * @section test-velocity-c test_velocity.c
 * @dontinclude test.c
 *
 * @skip test_clean
 * @until }
 *
 * @skip test_win_add
 * @until }
 *
 * @include test_velocity.c
 *
 * @example test_velocity.c
 */
